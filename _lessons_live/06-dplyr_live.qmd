---
title: Data Frame Manipulation with dplyr
embed-resources: true
editor_options: 
  chunk_output_type: console
---




## R Packages

We can install packages using `install.packages("packagename")`

```{r}
# install the tidyverse package
```


(Rather than saving this installation code, you should just run it directly in the console.)


You only ever need to *install* a package once, but you need to *load* it every time you want to use it:

```{r}
# load the tidyverse package

```



::: {.callout} 
## Challenge 5
Install and load the `dplyr` and `ggplot2` R packages.

:::





```{r}
#| message: false
library(tidyverse)
# load in gapminder
gapminder <- read.csv("data/gapminder_data.csv")
# look at the first 6 rows
head(gapminder)
# check the dimension
dim(gapminder)
# look at the str
str(gapminder)
# check the unique values of continent
unique(gapminder$continent)
```


Let's try to compute the average gdpPercap separately for each continent in the gapminder data:

```{r}
# compute the mean gdpPercap of Africa, Americas, Oceania, Europe, and Asia
# (using base R and logical row indexing)

```

Can we do this more neatly?










## The functions of `dplyr` package (part of the tidyverse)

0. Piping `|>`: Chain functions together

1. `select()`: Extract columns from a data frame

2. `filter()`: Subset the rows of a data frame using a logical condition

3. `mutate()`: Create new (or modify existing) columns in a data frame

4. `summarize()`: Compute summaries of the data in a data frame

5. `group_by()`: Compute functions separately across different levels of a categorical variable.






## Installing and loading dplyr (via the tidyverse)

```{r}
#| message: false
# Install the tidyverse if you haven't already
# Load the tidyverse library

```









## Extracting columns using select()


Select allows us to select a subset of the columns of our data frame

```{r}
# Define `year_country_gdp` (containing year, country, and gdpPercap only) using select()

# look at the head

```


Note the **lack of quotes** around the variables in select().





### Renaming variables using select() and rename()

```{r}
# Use select() to rename `gdpPercap` to gdp_per_cap 

```



```{r}
# Use rename() to rename `gdpPercap` to gdp_per_cap 

```



### Removing variables using select()


```{r}
# remove the continent variable from gapminder using select

```








## The pipe `|>` (originally `%>%`)


Defining the pipe:

```{r}
head(gapminder)
# rewrite the above code using the pipe |>

```





### Using the pipe to chain together functions:

```{r}
head(select(gapminder, year))
# rewrite the above code using the pipe |>

```








::: {.callout}
## Challenge 1

Rewrite the following code using the pipe:

1. 

```{r}
#| eval: false
select(gapminder, -continent)
```

2. 

```{r}
#| eval: false
head(select(gapminder, life_exp = lifeExp, gdp_per_cap = gdpPercap))
```


:::







## Filtering to rows using filter()

filter() allows us to subset the rows of our data frame using a logical condition. 

```{r}
# identify (using `$`) a logical condition for identifying which rows 
# correspond to Europe


# use filter (without the pipe) to filter to just the rows for Europe and 
# look at just the first 10 rows


# use filter (with the pipe) to filter to just the rows for Europe and
# look at just the first 10 rows

```






Let's use the pipe to chain together `select()` and `filter()`:

```{r}
# filter to the rows corresponding to Europe 
# then select just the year, country, gdpPercap columns
# and then view the head

```

Can we switch the order of `filter()` and `select()` for this example?








### Filtering with Multiple conditions 

Two ways to provide multiple conditions with "and" (both must be true):

```{r}
# Filter to countries in Europe in 2007 using &

# Filter to countries in Europe in 2007 using a comma (),)

```



How would you provide multiple conditions with "or" (at least one must be true)?


```{r}
# Filter to United States or Canada in two different ways
# option 1 (using |):

# option 2 (using %in%):

```






::: {.callout}
## Challenge 2

Use piping to produce a data frame that contains the `lifeExp`, `country` and `year` columns for African countries in 2002.  

Your data frame should have 52 rows and 3 columns (you can check this with `dim()`).

:::












## Adding and modifying columns using mutate()

You can add new columns using `mutate()`.

```{r}
# use mutate to define gdp_billion: gdpPercap * pop / 10^9 (and print the head)

```

You can also modify existing columns using `mutate()`.


```{r}
# use mutate to round lifeExp to the nearest integer (and print the head)

```









::: {.callout}
## Challenge 3

Explain what the following code is trying to do and explain why it doesn't work. Re-write the code so that it does work:

```{r}
#| error: true
gapminder |>
  filter(country == "Australia") |>
  select(year, lifeExp = round(lifeExp))
```


:::









## Creating summaries using summarize()

You can compute summaries using `summarize()`

```{r}
# compute the maximum life expectancy using summarize:

```

You can even compute multiple summaries at once

```{r}
# compute the min, mean, and max life expectancy using summarize:

```


```{r}
# compute the mean life expectancy and mean gdpPercap

```







## Grouped computations with group_by()

One way to compute the mean gdpPercap for each continent using base R is:

```{r}
mean(gapminder[gapminder$continent == "Africa", "gdpPercap"])
mean(gapminder[gapminder$continent == "Americas", "gdpPercap"])
mean(gapminder[gapminder$continent == "Asia", "gdpPercap"])
mean(gapminder[gapminder$continent == "Oceania", "gdpPercap"])
mean(gapminder[gapminder$continent == "Europe", "gdpPercap"])
```

We can rewrite this code using `summarize()` and `group_by()`

```{r}
# rewrite the above code using group_by() and summarize() and ungroup afterwards

```






`group_by()` can be used with any dplyr function. For example with mutate:

```{r}
# use group_by() and mutate() to add a column containing the continent's 
# average life expectancy

```

Note that the output is a "tibble"





### Grouping by multiple variables


```{r}
# compute the mean GDP per capita for each *country-year combination*

```





## Ordering the rows in a data frame using arrange()


```{r}
# Compute the average life expectancy for each country using group_by()
# Arrange the result in order of mean life expectancy using arrange()


```


What do you think will happen when we arrange using a character variable?

```{r}
# arrange the result above by `country`

```









## count() 

```{r}
# count the number of times each continent appears in the data using `count()`

```







