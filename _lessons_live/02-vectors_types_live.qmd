---
title: "Vectors and types"
output: html
embed-resources: true
editor_options: 
  chunk_output_type: console
---

## Datasets

Let's create a dataset in R using the `data.frame()` function:

```{r}
# define the cats data frame
cats_manual <- data.frame(coat = c("calico", "black", "tabby"),
                          weight = c(2.1, 5.0, 3.2),
                          likes_string = c(1, 0, 1))
```


Rather than "manually" creating datasets as above, more often you will need to load your data from a csv file stored "locally" on your computer:

```{r}
# load the cats data frame from the "data/feline-data.csv" csv file
# call it "cats"

```



## Working with `cats`

Let's extract some columns from `cats`:

```{r}
# extract the weight column using `$`

# extract the coat column using `$`

```

Each column in `cats` is a *vector*. 

There are lots of operations that we can do on vectors, such as:

```{r}
# add 2 to the weight vector

```

```{r}
# multiply the weight and likes_string vectors together

```

But what about:

```{r}
#| error: true
# try to add the weight and coat vectors together:

```

What happened?
















## Data Types


We can ask what type or "class" or "type" of data something is:

```{r}
# check the class() of the weight column

```








Three main types:

- `numeric` (which encompasses `double` and `integer`), 

- `logical`, 

- `character` 


Let's identify the class of several values:

```{r}
# identify the class of: 3.14, TRUE, and "banana"

```


Let's look at another version of the cats data that has an extra row:

```{r}
# read in "data/feline-data_v2.csv", save it as "cats2"

```


```{r}
# print out the new cats dataset

```

Let's check the class of the `weight` column

```{r}
# check the class of the weight column

```


The weight column is no longer numeric!

```{r}
#| error: true
# try to add 2 to the weight column

```

What happened?








The `str()` function can give you a quick overview of a data frame

```{r}
# use str() to identify the type of each column in cats

```









## Vectors and Type Coercion


A vector can be created with the `c()` "combine" function:

```{r}
# create a standalone vector (i.e. that does not come from a data frame) consisting of 1, 8, and 1.2 using c():

```



### Coercion by combining vectors


**Everything in the vector must be the same basic data type** so `c()` will *coerce* the type of each element to a common type. 

What do you think will be the type of the following vector?

```{r}
# create a vector containing 2, 6, and "3"

```









What about the following vectors:

```{r}
# a vector containing "a" and TRUE

# a vector containing 0 and TRUE

```













### The type hierarchy

The coercion rules go: `logical` > `numeric` > `character`


```{r}
# create a vector containing the entries 4 and "TRUE". What will its type be?

```









Forcing coercion using `as.numeric()`, `as.logical()`, etc:

```{r}
# create a vector with "0", "2", "4" (character values)

# coerce the vector to numeric using as.numeric()

# coerce the vector to a logical using as.logical()

```









::: {.callout}
## Challenge 1

In this exercise, you will clean the cat dataset.

Fill in the ____ gaps in the code below:

```{r}
#| eval: false
# Read data
cats <- read.csv("data/feline-data_v2.csv")
# 1. Print the data
_____

# 2. Show an overview of the table that prints out the type of each column
_____(cats)

# 3. The "weight" column has the incorrect data type __________.
#    The correct data type is: ____________.

# 4. Correct the 4th weight data point with the mean of the two given values
cats$weight[4] <- 2.35
#    print the data again to see the effect
cats

# 5. Convert the weight to the right data type
cats$weight <- ______________(cats$weight)

#    Calculate the mean to test yourself (you should get 3.16)
mean(cats$weight)

# If you see the correct mean value (and not NA), you did the exercise
# correctly!
```

:::













## Some basic functions for creating vectors

The combine function, `c()`, can also be used both to create a new vector as well as to append things to an existing vector:

```{r}
# create a new vector ab_vector with entries "a" and "b"

# add "z" to ab_vector

```








You can also make series of numbers using the `:` syntax as well as the `seq()` function:

```{r}
# create a vector with the numbers 1 to 10 using `:`

# print a vector with the numbers 1 to 10 using `seq()`

# print a vector with the numbers 1 to 10 using `seq()` with intervals of 0.1

```







The `head()` and `tail()` functions show the first and last few entries of a vector, respectively.

```{r}
# create a vector of integers from 20 to 25

# look at the first 2 entries using `head()`

# look at the last 4 entries using `tail()`

```








The `length()` function computes the number of entries in the vector:

```{r}
# compute the length of the vector above using `length()`

```

And the `class()` function reports the class/type of the values in the vector:

```{r}
# report the class of the vector above using `class()`

```










## Factors

Categorical variables/columns with a finite set of options will often be formatted as factor. 

```{r}
# look at the coat categorical variable from the cats data frame

```



```{r}
# identify the class of the coat variable

```


We can convert it to a factor using the `as.factor()` function:

```{r}
# convert the coat column from cats to a factor

# check its class

```



Let's take a look at the factor-formatted `coat` column:

```{r}
# take a look at the coat column

```


It looks very similar to the character format, but now our output tells us that there are "levels": "black", "calico", "tabby". 





### Converting factors to numeric: 

If we convert `coat` to a numeric type, it replaces each level with a number:

```{r}
# convert the coat column vector to numeric

```

But if the factor levels are themselves numbers, the numeric information gets lost:

```{r}
# create a factor version of the weight column

# convert the factor weight column vector to a numeric vector

```



